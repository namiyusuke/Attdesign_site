---
import Layout from '../../layouts/Layout.astro';
import { client, type Photo, type Category } from '../../lib/microcms';
import kumin from "@assets/img/kuu-icon.png"

export async function getStaticPaths() {
  const response = await client.getList<Photo>({
    endpoint: 'photo',
    queries: { limit: 100 }, // 全件取得（必要に応じて増やす）
  });
  return response.contents.map((photo) => ({
    params: { photoId: photo.id },
    props: { photo },
  }));
}
// microCMSからcategoryデータを取得
const categoryResponse = await client.getList<Category>({
  endpoint: 'category',
  queries: { limit: 100 },
});

const categories = categoryResponse.contents;

const { photo } = Astro.props;

// 日付をYYYY/MM/DD形式にフォーマット
const formatDate = (dateString: string) => {
  const date = new Date(dateString);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}/${month}/${day}`;
};

const createdAt = formatDate(photo.createdAt);
---

<Layout>
  <div class="header">
    <p class="header-icon">
      <img src={kumin.src} alt="">
    </p>
    <p class="header-icon-filter">View</p>
  </div>
  <div class="menu">
    <div class="menu-inner">
      <span class="menu-close"></span>
      <p>一瞬の空気感を切り取れるような1枚を目指して、写真の練習に励んでいます。</p>
      <p>『Photoire』＝写真で残す日々の記録です。</p>
      <p>Web design/Graphic design/<br>Direction support</p>
    </div>
  </div>
  <div class="menu-filter">
    <div class="menu-filter-inner">
      <span class="menu-close"></span>
      <ul>
        {categories.map((cat) => (
          <li>
            <a href={`/photo/?category=${cat.data}`}>{cat.data}</a>
          </li>
        ))}
      </ul>
    </div>
  </div>
  <!-- 背景用キャンバス（葉の影エフェクト） -->
  <canvas id="leaf-shadow-canvas"></canvas>
  <!-- 時間帯に応じた背景オーバーレイ -->
  <div id="time-overlay" class="time-overlay"></div>
  <main class="photo-detail">
    <div class="photo-detail-wrapper">
      <div class="photo-detail-body">
        <div class="photo-detail__image" id="bulge-container" data-image-url={photo.image.url}>
          <!-- WebGLでレンダリングされる -->
        </div>
      <div class="photo-detail-content">
        {photo.date ?
          <p class="photo-detail-date" set:html={photo.date} ></p>
          :
          <p class="photo-detail-date">{createdAt}</p>
        }
        {photo.title &&
          <h1 set:html={photo.title} ></h1>
        }

        {photo.text &&
            <p class="photo-detail-text" set:html={photo.text} />
        }

        {photo.camera &&
          <p class="photo-detail-camera">
            <Fragment set:html={photo.camera} />
          </p>
        }
        {photo.category?.data && <p class="photo-category">{photo.category.data}</p>}
      </div>
      </div>
    </div>
  </main>
</Layout>

<style>
  .menu-close{
    width: calc(20 / 16 * 1rem) ;
    height: calc(20 / 16 * 1rem) ;
    position: absolute;
    top: calc(24 / 16 * 1rem) ;
    right: calc(24 / 16 * 1rem) ;
    cursor: pointer;
  }
  .header-icon-filter{
    cursor: pointer;
    line-height: 1;
    background-color:#202020 ;
    color: #fff;
    padding-block: calc(12 / 16 * 1rem);
    padding-inline: 1rem;
    font-size: calc(14 / 16 * 1rem);
  }
  .menu-filter{
    position: fixed;
    top: 100px;
    right: 48px;
    width: 230px;
    color: #222;
    z-index: 10;
    opacity: 0;
    transform: translate(200px, -300%) rotate(-15deg);
    pointer-events: none;
    transition: opacity 0.4s ease-out, transform 1.4s cubic-bezier(0.16, 1, 0.3, 1);
    cursor: grab;
  }
  .menu-filter.is-active{
    opacity: 1;
    transform: translate(0, 0) rotate(3deg);
    pointer-events: auto;
  }
  .menu-filter.is-dragging{
    cursor: grabbing;
    transition: none;
  }
  .menu-filter-inner{
    padding-block: calc(80 / 16 * 1rem);
    padding-inline: calc(43 / 16 * 1rem);
    background-color: rgba(32, 32, 32, .9);
    text-align: center;
  }
   .menu-filter-inner a{
    color: #fff;
   }
  .menu-filter-inner ul{
    list-style: none;
  }
  .menu-filter-inner li +li{
    margin-top: calc(24 / 16 * 1rem);
  }
  .menu-close::after,
  .menu-close::before{
    position: absolute;
    margin: auto;
    content: "";
    width: 100%;
    height: 1px;
    background-color: #202020;
  }
  .menu-filter-inner .menu-close::after,
  .menu-filter-inner .menu-close::before{
    background-color: #fff;
  }
  .menu-close::after{
    transform: rotate(45deg);
  }
  .menu-close::before{
    transform: rotate(-45deg);
  }
  .header{
    position: fixed;
    top: calc(54 / 16 * 1rem) ;
    right: calc(48 / 16 * 1rem) ;
    z-index: 100;
    display: flex;
    align-items: center;
    flex-direction: row-reverse;
    column-gap: calc(24 / 16 * 1rem) ;;
  }
  .header-icon{
    width: calc(40 / 16 * 1rem);
    cursor: pointer;
  }
  .menu{
    position: fixed;
    top: 100px;
    right: 48px;
    width: 340px;
    color: #222;
    z-index: 10;
    opacity: 0;
    transform: translate(200px, -300%) rotate(-15deg);
    pointer-events: none;
    transition: opacity 0.4s ease-out, transform 1.4s cubic-bezier(0.16, 1, 0.3, 1);
    cursor: grab;
  }
  .menu.is-active{
    opacity: 1;
    transform: translate(0, 0) rotate(3deg);
    pointer-events: auto;
  }
  .menu.is-dragging{
    cursor: grabbing;
    transition: none;
  }
  .menu-inner{
    padding:calc(80 / 16 * 1rem);
    background-color: #fff;
  }
  /* 背景用キャンバス */
  #leaf-shadow-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    pointer-events: none;
  }

  .photo-detail {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    box-sizing: border-box;
  }
  .photo-detail-date{
    font-size:calc(16 / 16 * 1rem) ;
    margin-bottom: calc(20 / 16 * 1rem) ;
  }
  .photo-detail-camera{
    margin-bottom: calc(40 / 16 * 1rem) ;
  }
  .photo-detail__image {
    position: relative;
    width: 100%;
    aspect-ratio: 1/1;
    overflow: hidden;
  }
.photo-detail-text{
  margin-top:calc(40 / 16 * 1rem) ;
}
  .photo-detail__image canvas {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    object-fit: cover;
  }
  .photo-detail-content{
    margin-top:calc(84 / 16 * 1rem)
  }

  @media (min-width:768px) {
  .photo-detail-body{
    display: grid;
    column-gap:40px ;
    grid-template-columns: min(calc(600 / 1440 * 100vw),600px) 1fr;
  }
  }
  .photo-detail-wrapper{
    max-inline-size: 1046px;
    margin-inline: auto;
  }
  .photo-category{
    display: inline-block;
    background-color: #BFBFBF;
    font-weight: 700;
    line-height: 1;
    padding: calc(8 / 16 * 1rem) calc(12 / 16 * 1rem);
    font-size: calc(14 / 16 * 1rem);
  }

  /* 時間帯オーバーレイ */
  .time-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    pointer-events: none;
  }

  /* 朝 (5:00 - 10:00) */
  .time-overlay.is-morning {
    background: linear-gradient(69.03deg, rgba(255, 253, 253, 0.2) 0.81%, #C3F1FF 100%);
    opacity: 0.2;
  }

  /* 昼 (10:00 - 17:00) */
  .time-overlay.is-daytime {
    background: linear-gradient(69.03deg, rgba(255, 253, 253, 0.2) 0.81%, #C3F1FF 100%);
    opacity: 0.2;
  }

  /* 夕方 (17:00 - 19:00) */
  .time-overlay.is-evening {
    background: linear-gradient(69.03deg, rgba(255, 253, 253, 0.2) 0.81%, #FFC0A1 100%);
    opacity: 0.2;
  }

  /* 夜 (19:00 - 5:00) */
  .time-overlay.is-night {
    background: linear-gradient(69.03deg, rgba(255, 253, 253, 0.2) 0.81%, #040404 100%);
    opacity: 0.5;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    const headerIcon = document.querySelector('.header-icon') as HTMLElement | null;
    const menu = document.querySelector('.menu') as HTMLElement | null;
    const menuClose = document.querySelector('.menu-close') as HTMLElement | null;

    if (!headerIcon || !menu) return;

    let isMenuOpen = false;
    let isDragging = false;
    let startX = 0;
    let startY = 0;
    let initialX = 0;
    let initialY = 0;

    // メニューの初期位置を保存
    const menuRect = menu.getBoundingClientRect();
    let currentX = menuRect.left;
    let currentY = menuRect.top;

    const closeMenu = () => {
      isMenuOpen = false;
      menu.style.transform = 'translate(200px, -300%) rotate(-15deg)';
      menu.classList.remove('is-active');
    };

    // header-iconクリックでメニュー開閉
    headerIcon.addEventListener('click', () => {
      isMenuOpen = !isMenuOpen;

      if (isMenuOpen) {
        // 位置をリセットしてから開く
        menu.style.left = '';
        menu.style.top = '';
        menu.style.right = '48px';
        // メニューを開く（斜めに投げられるアニメーション）
        menu.classList.add('is-active');
        menu.style.transform = 'translate(0, 0) rotate(3deg)';
      }
    });

    // menu-closeクリックでアニメーションなしで即座に閉じる
    if (menuClose) {
      menuClose.addEventListener('click', (e: MouseEvent) => {
        e.stopPropagation();
        menu.style.transition = 'none';
        closeMenu();
        // 次フレームでtransitionを復元（再度開くときにアニメーションさせるため）
        requestAnimationFrame(() => {
          menu.style.transition = '';
        });
      });
    }

    // ドラッグ開始
    menu.addEventListener('mousedown', (e: MouseEvent) => {
      if (!isMenuOpen) return;

      isDragging = true;
      menu.classList.add('is-dragging');

      startX = e.clientX;
      startY = e.clientY;

      const rect = menu.getBoundingClientRect();
      initialX = rect.left;
      initialY = rect.top;

      e.preventDefault();
    });

    // ドラッグ中
    document.addEventListener('mousemove', (e: MouseEvent) => {
      if (!isDragging) return;

      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;

      currentX = initialX + deltaX;
      currentY = initialY + deltaY;

      menu.style.left = `${currentX}px`;
      menu.style.top = `${currentY}px`;
      menu.style.right = 'auto';
      menu.style.transform = 'translate(0, 0) rotate(3deg)';
    });

    // ドラッグ終了
    document.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        menu.classList.remove('is-dragging');
      }
    });

    // タッチデバイス対応
    menu.addEventListener('touchstart', (e: TouchEvent) => {
      if (!isMenuOpen) return;

      isDragging = true;
      menu.classList.add('is-dragging');

      const touch = e.touches[0];
      startX = touch.clientX;
      startY = touch.clientY;

      const rect = menu.getBoundingClientRect();
      initialX = rect.left;
      initialY = rect.top;
    });

    document.addEventListener('touchmove', (e: TouchEvent) => {
      if (!isDragging) return;

      const touch = e.touches[0];
      const deltaX = touch.clientX - startX;
      const deltaY = touch.clientY - startY;

      currentX = initialX + deltaX;
      currentY = initialY + deltaY;

      menu.style.left = `${currentX}px`;
      menu.style.top = `${currentY}px`;
      menu.style.right = 'auto';
      menu.style.transform = 'translate(0, 0) rotate(3deg)';
    });

    document.addEventListener('touchend', () => {
      if (isDragging) {
        isDragging = false;
        menu.classList.remove('is-dragging');
      }
    });

    // --- menu-filter の開閉・ドラッグ ---
    const headerIconFilter = document.querySelector('.header-icon-filter') as HTMLElement | null;
    const menuFilter = document.querySelector('.menu-filter') as HTMLElement | null;
    const menuFilterClose = menuFilter?.querySelector('.menu-close') as HTMLElement | null;

    if (headerIconFilter && menuFilter) {
      let isFilterOpen = false;
      let isFilterDragging = false;
      let filterStartX = 0;
      let filterStartY = 0;
      let filterInitialX = 0;
      let filterInitialY = 0;

      const closeFilter = () => {
        isFilterOpen = false;
        menuFilter.style.transform = 'translate(200px, -300%) rotate(-15deg)';
        menuFilter.classList.remove('is-active');
      };

      headerIconFilter.addEventListener('click', () => {
        isFilterOpen = !isFilterOpen;
        if (isFilterOpen) {
          // 既存メニューが開いていたら閉じる
          closeMenu();
          menuFilter.style.left = '';
          menuFilter.style.top = '';
          menuFilter.style.right = '48px';
          menuFilter.classList.add('is-active');
          menuFilter.style.transform = 'translate(0, 0) rotate(3deg)';
        }
      });

      if (menuFilterClose) {
        menuFilterClose.addEventListener('click', (e: MouseEvent) => {
          e.stopPropagation();
          menuFilter.style.transition = 'none';
          closeFilter();
          requestAnimationFrame(() => {
            menuFilter.style.transition = '';
          });
        });
      }

      // ドラッグ
      menuFilter.addEventListener('mousedown', (e: MouseEvent) => {
        if (!isFilterOpen) return;
        isFilterDragging = true;
        menuFilter.classList.add('is-dragging');
        filterStartX = e.clientX;
        filterStartY = e.clientY;
        const rect = menuFilter.getBoundingClientRect();
        filterInitialX = rect.left;
        filterInitialY = rect.top;
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e: MouseEvent) => {
        if (!isFilterDragging) return;
        const deltaX = e.clientX - filterStartX;
        const deltaY = e.clientY - filterStartY;
        menuFilter.style.left = `${filterInitialX + deltaX}px`;
        menuFilter.style.top = `${filterInitialY + deltaY}px`;
        menuFilter.style.right = 'auto';
        menuFilter.style.transform = 'translate(0, 0) rotate(3deg)';
      });

      document.addEventListener('mouseup', () => {
        if (isFilterDragging) {
          isFilterDragging = false;
          menuFilter.classList.remove('is-dragging');
        }
      });

      // タッチ対応
      menuFilter.addEventListener('touchstart', (e: TouchEvent) => {
        if (!isFilterOpen) return;
        isFilterDragging = true;
        menuFilter.classList.add('is-dragging');
        const touch = e.touches[0];
        filterStartX = touch.clientX;
        filterStartY = touch.clientY;
        const rect = menuFilter.getBoundingClientRect();
        filterInitialX = rect.left;
        filterInitialY = rect.top;
      });

      document.addEventListener('touchmove', (e: TouchEvent) => {
        if (!isFilterDragging) return;
        const touch = e.touches[0];
        const deltaX = touch.clientX - filterStartX;
        const deltaY = touch.clientY - filterStartY;
        menuFilter.style.left = `${filterInitialX + deltaX}px`;
        menuFilter.style.top = `${filterInitialY + deltaY}px`;
        menuFilter.style.right = 'auto';
        menuFilter.style.transform = 'translate(0, 0) rotate(3deg)';
      });

      document.addEventListener('touchend', () => {
        if (isFilterDragging) {
          isFilterDragging = false;
          menuFilter.classList.remove('is-dragging');
        }
      });
    }
  });
</script>
