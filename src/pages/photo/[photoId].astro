---
import Layout from '../../layouts/Layout.astro';
import { client, type Photo } from '../../lib/microcms';

export async function getStaticPaths() {
  const response = await client.getList<Photo>({ endpoint: 'photo' });
  return response.contents.map((photo) => ({
    params: { photoId: photo.id },
    props: { photo },
  }));
}

const { photo } = Astro.props;

// 日付をYYYY/MM/DD形式にフォーマット
const formatDate = (dateString: string) => {
  const date = new Date(dateString);
  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}/${month}/${day}`;
};

const createdAt = formatDate(photo.createdAt);
---

<Layout>
  <!-- 背景用キャンバス（葉の影エフェクト） -->
  <canvas id="leaf-shadow-canvas"></canvas>
  <main class="photo-detail">
    <div class="photo-detail-wrapper">
      <div class="photo-detail-body">
        <div class="photo-detail__image" id="bulge-container" data-image-url={photo.image.url}>
          <!-- WebGLでレンダリングされる -->
        </div>
      <div class="photo-detail-content">
        {photo.date ?
          <p set:html={photo.date} ></p>
          :
          <p>{createdAt}</p>
        }
        {photo.title &&
          <h1 set:html={photo.title} ></h1>
        }
        {photo.text &&
          <Fragment set:html={photo.text} />
        }
        {photo.camera &&
          <p>
            <Fragment set:html={photo.camera} />
          </p>
        }
        {photo.category?.data && <p class="photo-category">{photo.category.data}</p>}
      </div>
      </div>
    </div>
  </main>
</Layout>

<style>
  /* 背景用キャンバス */
  #leaf-shadow-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    pointer-events: none;
  }

  .photo-detail {
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    padding: 2rem;
    box-sizing: border-box;
  }

  .photo-detail__image {
    position: relative;
    width: 100%;
    aspect-ratio: 1/1;
    overflow: hidden;
  }

  .photo-detail__image canvas {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    object-fit: cover;
  }
  .photo-detail-content{
    margin-top:calc(84 / 16 * 1rem)
  }
  .photo-detail-body{
    display: grid;
    column-gap:40px ;
    grid-template-columns: calc(600 / 1046 * 100%) calc(406 / 1046 * 100%);
  }
  .photo-detail-wrapper{
    max-inline-size: 1046px;
    margin-inline: auto;
  }
  .photo-category{
    display: inline-block;
    background-color: #BFBFBF;
    font-weight: 700;
    line-height: 1;
    padding: calc(8 / 16 * 1rem) calc(12 / 16 * 1rem);
    font-size: calc(14 / 16 * 1rem);
  }
</style>

<script>
  import * as THREE from 'three';

  // 葉の影の背景エフェクト
  const initLeafShadow = () => {
    const canvas = document.getElementById('leaf-shadow-canvas');
    if (!canvas) return;

    // 既存のWebGLコンテキストがあればクリーンアップ
    if (canvas.__renderer) {
      canvas.__renderer.dispose();
    }

    const scene = new THREE.Scene();
    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 10);
    camera.position.z = 1;

    const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // rendererをcanvasに保存（クリーンアップ用）
    canvas.__renderer = renderer;

    const vertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const fragmentShader = `
      uniform float uTime;
      uniform float uAmplitude;
      uniform float uSpeed;
      uniform float uScreenAspect;
      uniform float uTextureAspect;
      uniform sampler2D uTexture;
      varying vec2 vUv;

      vec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }
      float snoise(vec2 v) {
        const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
        vec2 i = floor(v + dot(v, C.yy));
        vec2 x0 = v - i + dot(i, C.xx);
        vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;
        i = mod(i, 289.0);
        vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
        m = m*m*m*m;
        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;
        m *= 1.79284291400159 - 0.85373472095314 * (a0*a0 + h*h);
        vec3 g;
        g.x = a0.x * x0.x + h.x * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
      }

      void main() {
        vec2 uv = vUv;

        // アスペクト比を補正（object-fit: cover のような動作）
        if (uScreenAspect > uTextureAspect) {
          // 画面が横長：横幅に合わせ、縦をクロップ
          float scale = uScreenAspect / uTextureAspect;
          uv.y = (uv.y - 0.5) / scale + 0.5;
        } else {
          // 画面が縦長：縦幅に合わせ、横をクロップ
          float scale = uTextureAspect / uScreenAspect;
          uv.x = (uv.x - 0.5) / scale + 0.5;
        }

        float time = uTime * uSpeed;
        float noise1 = snoise(vec2(uv.x * 3.0 + time * 0.3, uv.y * 2.0 + time * 0.2));
        float noise2 = snoise(vec2(uv.x * 5.0 - time * 0.2, uv.y * 4.0 + time * 0.35)) * 0.5;
        // float noise3 = snoise(vec2(uv.x * 8.0 + time * 0.1, uv.y * 6.0 - time * 0.25)) * 0.25;
        float combinedNoise = noise1 + noise2 ;
        float displacement = combinedNoise * uAmplitude * 0.001;
        uv.x += displacement * 1.5;
        uv.y += displacement * 0.5;
        uv = clamp(uv, 0.0, 1.0);
        gl_FragColor = texture2D(uTexture, uv);
      }
    `;

    let material = null;
    let textureAspect = 1;
    const textureLoader = new THREE.TextureLoader();

    // アスペクト比のuniformを更新
    function updateAspect() {
      if (!material) return;
      material.uniforms.uScreenAspect.value = window.innerWidth / window.innerHeight;
    }

    // shadow.pngを読み込み
    textureLoader.load('/shadow.png', (texture) => {
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;

      // テクスチャのアスペクト比を取得
      textureAspect = texture.image.width / texture.image.height;

      material = new THREE.ShaderMaterial({
        uniforms: {
          uTime: { value: 0 },
          uAmplitude: { value: 5 },
          uSpeed: { value: 1.0 },
          uScreenAspect: { value: window.innerWidth / window.innerHeight },
          uTextureAspect: { value: textureAspect },
          uTexture: { value: texture },
        },
        vertexShader,
        fragmentShader,
        transparent: true,
      });

      const geometry = new THREE.PlaneGeometry(2, 2);
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      animate();
    });

    function animate() {
      requestAnimationFrame(animate);
      if (material) material.uniforms.uTime.value += 0.016;
      renderer.render(scene, camera);
    }

    const handleResize = () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      updateAspect();
    };

    window.addEventListener('resize', handleResize);
  };

  // ページ読み込み時に初期化
  initLeafShadow();

  // swupのページ遷移後にも再初期化
  document.addEventListener('swup:contentReplaced', () => {
    initLeafShadow();
  });
</script>
